





# 深入理解浏览器的缓存机制



## 一、前言

**`缓存可以说是性能优化中简单高效的一种优化方式了。`** 



## 二、缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

* **`Service Worker`** 
* **`Memory Cache`** 
* **`Disk Cache`** 
* **`Push Cache`** 



### 1. Service Worker

**`Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与其他浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。`** 

**`Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。`** 

**`当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。`** 



### 2. Memory Cache

**`Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。`** 

**`那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？`** 

**`这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。`** 

**`当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。`** 

**`内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如 <link rel="prefetch">）下载的资源。众所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。`** 

**`需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type、CORS 等其他特征做校验。`** 



### 3. Disk Cache

**`Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到硬盘中，比之 Memory Cache 胜在容量和存储时效性上。`** 

**`在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。`** 

**`浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？`** 

**`关于这点，网上说法不一，不过以下观点比较靠得住：`** 

* **`对于大文件来说，大概率是不存储在内存中的，反之优先。`** 
* **`当前系统内存使用率高的话，文件优先存储进硬盘。`** 



### 4. Push Cache





**`如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。`** 

**`那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。`** 



## 三、缓存过程分析

由上图我们可以知道：

* **`浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识`** 
* **`浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中`** 



## 四、强缓存

**`强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。`** 



### 1. Expires

**`缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires = max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。`**

**`Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。`** 



### 2. Cache-Control

**`在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 Cache-Control: max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。`** 

**`Cache-Control 可以在请求头或响应头中设置，并且可以组合使用多种指令：`** 

**`public：所有内容都将被缓存（客户端和代理服务器都可缓存）。`**

**`private：所有内容只有客户端可以缓存。`**

**`no-cache：浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。`**

**`no-store：所有内容都不会被缓存，即不使用强缓存，也不使用协商缓存。`**





### 3. Expires 和 Cache-Control 两者对比

其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires。在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。



## 五、协商缓存

**`协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要由以下两种情况：`** 

* **`协商缓存生效，返回 304 和 Not Modified`** 
* **`协商缓存失效，返回 200 和请求结果`** 

**`协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag。`** 



### 1. Last-Modified 和 If-Modified-Since

**浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header·** 

```powershell
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

**`浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200。`** 





### 2. ETag 和 If-None-Match

**`Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源由有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 Etag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 Etag 匹配不上，那么直接以常规 GET 200 形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 告知客户端直接使用本地缓存即可。`**



### 3. 两者之间对比：

* **`首先在精确度上，Etag 要优于 Last-Modified。`** 

**`Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了很多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精确度，如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。`** 

* **`第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。`** 
* **`第三在优先级上，服务器校验优化考虑 Etag。`** 





## 六、缓存机制

**`强缓存优先于协商缓存进行，若强制缓存（Expires 和 Cache-Control）生效则直接使用缓存，若不生效则进行协商缓存（Last-Modified / If-Modified-Since 和 Etag / If-None-Match），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中，生效返回 304，继续使用缓存。`**

**`看到这里，不知道你是否存在这样一个疑问：如果什么缓存策略都没设置，那么浏览器会怎么处理？`** 

**`对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。`** 



## 七、实际场景应用缓存策略

### 1. 频繁变动的资源

>Cache-Control: no-cache

**`对于频繁变动的资源，首先需要使用 Cache-Control：no-cache。使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。`** 



### 2. 不常变化的资源

>Cache-Control: max-age=31536000

**`通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000（一年），这样浏览器之后请求相同的 URL 会命中强缓存。而为了解决更新的问题，就需要在文件名（或者路径）中添加 hash，版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强缓存失效（其实并未立即失效，只是不再使用了而已）。`** 



## 八、用户行为对浏览器缓存的影响

**`所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：`** 

* **`打开网页，地址栏输入地址：查找 disk cache 是是否有匹配。如有则使用，如没有则发送网络请求。`** 
* **`普通刷新（F5）：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用（如果匹配的话）。其次才是 disk cache。`** 
* **`强制刷新（Ctrl + F5）：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control：no-cache（为了兼容，还带了 Pragma: no-cache），服务器直接返回 200 和最新内容。`** 

















# 事件循环 Event Loop

**`事件循环（Event Loop）是 JavaScript 实现异步非阻塞的关键机制。它不断地循环检查任务队列，并决定下一步执行哪个任务。理解宏任务（macrotask）和微任务（microtask）在事件循环中的执行顺序对于编写高性能的 JavaScript 代码至关重要。`** 

## 宏任务
**`宏任务： 宏任务是由宿主环境（例如浏览器或 Node.js）发起的任务。常见的宏任务包括：`**
* **`setTimeout`**  
* **`setInterval`**  
* **`setImmediate (Node.js) `** 
* **`I/O 操作`** 
* **`UI 渲染`**  
* **`script (首次执行的脚本)`** 

## 微任务
**`微任务： 微任务是由 JavaScript 引擎自身发起的任务。常见的微任务包括：`**
* **`Promise.then`**  
* **`MutationObserver`**  
* **`process.nextTick (Node.js) `** 
* **`queueMicrotask`** 

## 执行顺序
**`事件循环的每一次循环称为一个 "tick"。在一个 tick 中，事件循环会按照以下顺序执行任务：`** 

**`1. 执行栈： 首先执行栈中的所有同步代码会被执行完毕`**

**`2. 微任务队列：接下来事件循环会检查微任务队列，并执行队列中所有的微任务。只有当微任务队列为空时，才会进入下一个宏任务。如果在执行微任务的过程中，又产生了新的微任务，那么新的微任务会加入到队列末尾，并在当前 tick 中继续执行`**

**`3. 宏任务队列：当微任务队列为空时，事件循环会从宏任务队列中取出一个任务执行`**

**`4. 渲染：浏览器会更新渲染页面`**

**`5. 事件循环会不断重复以上步骤`**

## 总结

**`事件循环的执行顺序是：`**

**`1. 执行栈中的同步代码`**

**`2. 执行所有可执行的微任务`**

**`3. 执行一个宏任务`**

**`4. 更新渲染`**

**`5. 重复以上步骤`**

## 如果在执行微任务的过程中，又产生了新的微任务，那么新的微任务会加入到微任务队列的末尾，并且在当前 tick 中继续执行

**`示例`**
```javascript
console.log("script start);

Promise.resolve().then(function() {
  console.log("promise1");

  Promise.resolve().then(function() {
    console.log("promise2");
  });
});

setTimeout(function() {
  console.log("setTimeout");
}, 0);

console.log("script end");
```

**`输出结果`**
```
script start
script end
promise1
promise2
setTimeout
```




# 输入 URL 到页面渲染的整个流程

## DNS

**`DNS 的作用就是通过域名查询到具体的 IP。`** 

## TCP 

**`在这一部分中，可以详细说下 TCP 的握手情况以及 TCP 的一些特性。`** 

## HTTP

**`假设服务端会响应一个 HTML 文件。`** 

## 浏览器渲染原理

# 浏览器渲染原理

## 浏览器接收到 HTML 文件并转换为 DOM 树

**`当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 js、css、html 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实是 0 和 1 这些 字节数据。当浏览器接收到这些字节数据以后，它会将这些 字节数据转换为字符串，也就是我们写的代码。`** 

![](https://github.com/WqhForGitHub/browser-basics/blob/main/static/1.png?raw=true)

**`当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为 标记（token），这一过程在词法分析中叫做 标记化（tokenization）。`** 

![](https://github.com/WqhForGitHub/browser-basics/blob/main/static/2.png?raw=true)

**`那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的 最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。`**

![](https://github.com/WqhForGitHub/browser-basics/blob/main/static/3.png?raw=true)

**`当结束话标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。`** 

![](https://github.com/WqhForGitHub/browser-basics/blob/main/static/4.png?raw=true)

**`以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。`** 

![](https://github.com/WqhForGitHub/browser-basics/blob/main/static/5.png?raw=true)

**`当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 CSS 文件。`** 

## 将 CSS 文件转换为 CSSOM 树

**`其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的`** 

![](https://github.com/WqhForGitHub/browser-basics/blob/main/static/6.png?raw=true)

**`在这一过程中，浏览器会确定下每一个节点的 样式 到底是什么，并且这一过程其实是 很消耗资源 的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得 递归 CSSOM 树，然后确定具体的元素到底是什么样式。`** 

## 生成渲染树

**`当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。`** 

![](https://github.com/WqhForGitHub/browser-basics/blob/main/static/7.png?raw=true)

**`在这一过程中，不是简单的将两者合并就行了。渲染树只会包括 需要显示的节点 和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。`** 

**`当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。`** 

