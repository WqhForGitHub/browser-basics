



# 深入浅出浏览器渲染原理



## 浏览器渲染过程



**`浏览器渲染过程大体分为如下三部分：`** 



### 1. 浏览器会解析三个东西：

* **`一是 HTML/SVG/XHTML，HTML 字符串描述了一个页面的结构，浏览器会把 HTML 结构字符串解析转换 DOM 树形结构。`** 
* **`二是 CSS，解析 CSS 会产生 CSS 规则树，它和 DOM 结构比较像。`** 
* **`三是 JavaScript 脚本，等到 JavaScript 脚本文件加载后，通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。`** 



### 2. 解析完成后，浏览器引擎会通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。

* **`Rendering Tree 渲染树并不等同于 DOM 树，渲染树只会包括需要显示的节点和这些节点的样式信息。`** 
* **`CSS 的 Rule Tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering Tree 上的每个 Element（也就是每个 Frame）。`** 
* **`然后，计算每个 Frame 的位置，这又叫 layout 和 reflow 过程。`** 



### 3. 最后通过调用操作系统 GUI 的 API 绘制。



## 构建 DOM

**`浏览器会遵守一套步骤将 HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：`** 

* **`浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码将它们转换成字符串。`** 

**`在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。`** 

* **`将字符串转换成 Token，例如：<html>、<body> 等。Token 中标识出当前 Token 是开始标签或是结束标签亦或是文本等信息。`** 

**`这时候你一定会有疑问，节点与节点之间的关系如何维护？`** 

**`事实上，这就是 Token 要标识起始标签和结束标签等标识的作用。例如 title Token 的起始标签和结束标签之间的节点肯定是属于 head 的子节点。`** 

**`上图给出了节点之间的关系，例如：Hello Token 位于 title 开始标签与 title 结束标签之间，表明 Hello Token 是 title Token 的子节点。同理 title Token 是 head Token 的子节点。`**

* **`生成节点对象并构建 DOM`** 



## 构建 CSSOM



## 构建渲染树

**`当我们生成 DOM 树和 CSSOM 树以后，就需要将这两颗树组合为渲染树。`** 

**`在这一过程中，不是简单的将两者合并就行了。渲染树只会包含需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。`** 

**`我们或许有个疑惑：浏览器如果渲染过程中遇到 JS 文件怎么处理？`** 

**`渲染过程中，如果遇到 <script> 就停止渲染，执行 JS 代码。因为浏览器有 GUI 渲染线程与 JS 引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript 的加载、解析与执行会阻塞 DOM 的构建，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停构建 DOM，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复 DOM 构建。`** 

**`也就是说，如果你想要首屏渲染的越快，就越不应该再首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。`** 

**`JS 文件不只是阻塞 DOM 的构建，它会导致 CSSOM 也阻塞 DOM 的构建。`** 

**`原本 DOM 和 CSSOM 的构建是互不影响，井水不犯河水，但是一旦引入了 JavaScript，CSSOM 也开始阻塞 DOM 的构建，只有 CSSOM 构建完毕后，DOM 再恢复 DOM 构建。`** 

**`这是什么情况？`** 

**`这是因为 JavaScript 不只是可以改 DOM，它还可以更改样式，也就是它可以更改 CSSOM。因为不完整的 CSSOM 是无法使用的，如果 JavaScript 想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到完整的 CSSOM。所以就导致了一个现象，如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后在继续构建 DOM。`** 



## 布局与绘制

**`当浏览器生成渲染树以后，就会根据渲染树来进行布局。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为自动重排。`** 

**`布局流程的输出是一个盒模型，它会精确地捕获每个元素在视口内地确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。`** 







## 几点补充说明



### 1. async 和 defer 的作用是什么？有什么区别？



**`1. <script src="script.js"></script>`**

**`没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。`** 



**`2. <script async src="script.js"></script>（异步加载）`**

**`async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好了，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async - script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。`** 



**`3. <script defer src="script.js"></script>（延迟执行）`**

**`defer 属性表示延迟执行进入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer - script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer - script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。`** 

**`defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。`** 





### 2. 为什么操作 DOM 慢

**`因为 DOM 是属于渲染引擎的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了通信，这种跨引擎的通信会带来性能上的开销。`**



### 3. 你真的了解回流和重绘吗

* **`重绘：当我们对 DOM 的修改导致了样式的变化、却未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式。`** 
* **`回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流。`** 



**`回流必定会发生重绘，重绘不一定引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能导致父节点的一系列回流。`**  



**`1. 常见引起回流属性和方法`**

任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。

* **`添加或者删除可见的 DOM 元素`**
* **`元素尺寸改变，边距、填充、边框、宽度和高度`**
* **`内容变化，比如用户在 input 框中输入文字`**
* **`浏览器窗口尺寸改变，resize 事件发生时`**
* **`计算 offsetWidth 和 offsetHeight 属性`**
* **`设置 style 属性的值`**



**`2. 常见引起重绘属性和方法`**



**`3. 如何减少回流、重绘`**

* **`使用 transform 替代 top`** 
* **`使用 visibility 替换 display: none，因为前者只会引起重绘，后者会引发回流。`** 
* **`不要把节点的属性值放在一个循环里面当成循环里的变量。`** 

```javascript
for (let i = 0; i < 1000; i++) {
    console.log(document.querySelector(".test").style.offsetTop);
}
```

* **`不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局`** 
* **`CSS 选择符从右往左匹配查找，避免节点层级过多`** 



## 性能优化策略

**`基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。`** 

* **`JS 优化：<script> 标签加上 defer 属性和 async 属性用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。`** 
  * **`defer 属性：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。`** 
  * **`async 属性：HTML5 新增属性，用于异步加载脚本文件，下载完毕立即解释执行代码。`** 
* **`CSS 优化：<link> 标签的 rel 属性中的属性值设置为 preload 能够让你在你的 HTML 页面中可以指明哪些资源是在页面加载完成后即刻需要的，最优的配置加载顺序，提高渲染性能。`** 







# 深入理解浏览器的缓存机制



## 一、前言

**`缓存可以说是性能优化中简单高效的一种优化方式了。`** 



## 二、缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

* **`Service Worker`** 
* **`Memory Cache`** 
* **`Disk Cache`** 
* **`Push Cache`** 



### 1. Service Worker

**`Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与其他浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。`** 

**`Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。`** 

**`当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。`** 



### 2. Memory Cache

**`Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。`** 

**`那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？`** 

**`这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。`** 

**`当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。`** 

**`内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如 <link rel="prefetch">）下载的资源。众所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。`** 

**`需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type、CORS 等其他特征做校验。`** 



### 3. Disk Cache

**`Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到硬盘中，比之 Memory Cache 胜在容量和存储时效性上。`** 

**`在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。`** 

**`浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？`** 

**`关于这点，网上说法不一，不过以下观点比较靠得住：`** 

* **`对于大文件来说，大概率是不存储在内存中的，反之优先。`** 
* **`当前系统内存使用率高的话，文件优先存储进硬盘。`** 



### 4. Push Cache





**`如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。`** 

**`那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。`** 



## 三、缓存过程分析

由上图我们可以知道：

* **`浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识`** 
* **`浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中`** 



## 四、强缓存

**`强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。`** 



### 1. Expires

**`缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires = max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。`**

**`Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。`** 



### 2. Cache-Control

**`在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 Cache-Control: max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。`** 

**`Cache-Control 可以在请求头或响应头中设置，并且可以组合使用多种指令：`** 

**`public：所有内容都将被缓存（客户端和代理服务器都可缓存）。`**

**`private：所有内容只有客户端可以缓存。`**

**`no-cache：浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。`**

**`no-store：所有内容都不会被缓存，即不使用强缓存，也不使用协商缓存。`**





### 3. Expires 和 Cache-Control 两者对比

其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires。在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。



## 五、协商缓存

**`协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要由以下两种情况：`** 

* **`协商缓存生效，返回 304 和 Not Modified`** 
* **`协商缓存失效，返回 200 和请求结果`** 

**`协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag。`** 



### 1. Last-Modified 和 If-Modified-Since

**浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header·** 

```powershell
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

**`浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200。`** 





### 2. ETag 和 If-None-Match

**`Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源由有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 Etag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 Etag 匹配不上，那么直接以常规 GET 200 形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 告知客户端直接使用本地缓存即可。`**



### 3. 两者之间对比：

* **`首先在精确度上，Etag 要优于 Last-Modified。`** 

**`Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了很多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精确度，如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。`** 

* **`第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。`** 
* **`第三在优先级上，服务器校验优化考虑 Etag。`** 





## 六、缓存机制

**`强缓存优先于协商缓存进行，若强制缓存（Expires 和 Cache-Control）生效则直接使用缓存，若不生效则进行协商缓存（Last-Modified / If-Modified-Since 和 Etag / If-None-Match），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中，生效返回 304，继续使用缓存。`**

**`看到这里，不知道你是否存在这样一个疑问：如果什么缓存策略都没设置，那么浏览器会怎么处理？`** 

**`对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。`** 



## 七、实际场景应用缓存策略

### 1. 频繁变动的资源

>Cache-Control: no-cache

**`对于频繁变动的资源，首先需要使用 Cache-Control：no-cache。使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。`** 



### 2. 不常变化的资源

>Cache-Control: max-age=31536000

**`通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000（一年），这样浏览器之后请求相同的 URL 会命中强缓存。而为了解决更新的问题，就需要在文件名（或者路径）中添加 hash，版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强缓存失效（其实并未立即失效，只是不再使用了而已）。`** 



## 八、用户行为对浏览器缓存的影响

**`所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：`** 

* **`打开网页，地址栏输入地址：查找 disk cache 是是否有匹配。如有则使用，如没有则发送网络请求。`** 
* **`普通刷新（F5）：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用（如果匹配的话）。其次才是 disk cache。`** 
* **`强制刷新（Ctrl + F5）：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control：no-cache（为了兼容，还带了 Pragma: no-cache），服务器直接返回 200 和最新内容。`** 

















# 事件循环 Event Loop

**`事件循环（Event Loop）是 JavaScript 实现异步非阻塞的关键机制。它不断地循环检查任务队列，并决定下一步执行哪个任务。理解宏任务（macrotask）和微任务（microtask）在事件循环中的执行顺序对于编写高性能的 JavaScript 代码至关重要。`** 

## 宏任务
**`宏任务： 宏任务是由宿主环境（例如浏览器或 Node.js）发起的任务。常见的宏任务包括：`**
* **`setTimeout`**  
* **`setInterval`**  
* **`setImmediate (Node.js) `** 
* **`I/O 操作`** 
* **`UI 渲染`**  
* **`script (首次执行的脚本)`** 

## 微任务
**`微任务： 微任务是由 JavaScript 引擎自身发起的任务。常见的微任务包括：`**
* **`Promise.then`**  
* **`MutationObserver`**  
* **`process.nextTick (Node.js) `** 
* **`queueMicrotask`** 

## 执行顺序
**`事件循环的每一次循环称为一个 "tick"。在一个 tick 中，事件循环会按照以下顺序执行任务：`** 

**`1. 执行栈： 首先执行栈中的所有同步代码会被执行完毕`**

**`2. 微任务队列：接下来事件循环会检查微任务队列，并执行队列中所有的微任务。只有当微任务队列为空时，才会进入下一个宏任务。如果在执行微任务的过程中，又产生了新的微任务，那么新的微任务会加入到队列末尾，并在当前 tick 中继续执行`**

**`3. 宏任务队列：当微任务队列为空时，事件循环会从宏任务队列中取出一个任务执行`**

**`4. 渲染：浏览器会更新渲染页面`**

**`5. 事件循环会不断重复以上步骤`**

## 总结

**`事件循环的执行顺序是：`**

**`1. 执行栈中的同步代码`**

**`2. 执行所有可执行的微任务`**

**`3. 执行一个宏任务`**

**`4. 更新渲染`**

**`5. 重复以上步骤`**

## 如果在执行微任务的过程中，又产生了新的微任务，那么新的微任务会加入到微任务队列的末尾，并且在当前 tick 中继续执行

**`示例`**
```javascript
console.log("script start);

Promise.resolve().then(function() {
  console.log("promise1");

  Promise.resolve().then(function() {
    console.log("promise2");
  });
});

setTimeout(function() {
  console.log("setTimeout");
}, 0);

console.log("script end");
```

**`输出结果`**
```
script start
script end
promise1
promise2
setTimeout
```





# 从 URL 输入到页面展现到底发生了什么？



## 前言：

**`总体来说分为以下几个过程：`** 

* **`DNS 解析：将域名解析成 IP 地址`** 
* **`TCP 连接：TCP 三次握手`** 
* **`发送 HTTP 请求`** 
* **`服务器处理请求并返回 HTTP 报文`** 
* **`浏览器解析渲染页面`** 
* **`断开连接：TCP 四次握手`** 



## 一、URL 到底是啥

**`URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。`** 

**`scheme://host.domain:port/path/filename`** 

**`各部分解释如下：`** 

**`scheme：定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。`** 

**`host：定义域主机（http 的默认主机是 www）`** 

**`domain：定义因特网域名，比如 w3school.com.cn`** 

**`port：定义主机上的端口号（http 的默认端口号是 80）`** 

**`path：定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）`** 

**`filename：定义文档/资源的名称`** 



## 二、域名解析（DNS）





## 三、TCP 三次握手





## 四、发送 HTTP 请求





## 五、服务器处理请求并返回 HTTP 报文





## 六、浏览器解析渲染页面





## 七、断开连接

